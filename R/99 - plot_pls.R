
#' \code{PlotPLS2DScore} - plot 2D score plot.
#' @param inx1,inx2 The order numbers of PCs.
#' @param reg Set the confidence level for plotting confidence region ellipse.
#' @param show If \code{TRUE} then points at the plot are labeled.
#' @rdname PlotPLS
#' @export
# score plot
plot_PLS_scores <- function(df, inx1 = 1, inx2 = 2,
                            reg = 0.95, show = TRUE) {
  df <- logTransform(df)
  df <- normScale(df)
  
  pls <- PLS_anal(df)
  xlabel = paste("Component", inx1, "(", round(100*pls$Xvar[inx1]/pls$Xtotvar, 1), "%)");
  ylabel = paste("Component", inx2, "(", round(100*pls$Xvar[inx2]/pls$Xtotvar, 1), "%)");
  pc1 = pls$scores[, inx1];
  pc2 = pls$scores[, inx2];
  text.lbls <- substr(row.names(pls$model$datmat), 1, 12) # some names may be too long

  par(mar = c(5,5,3,3));

  color <- mapvalues(row.names(pls$model$datmat),
                     df$sampleData$sample_ID,
                     df$sampleData$color)
  plot(pc1, pc2, xlab = xlabel, ylab = ylabel, type = 'n', main = "Scores Plot")
  points(pc1, pc2, pch = 23, col = "black", bg = color, cex = 2)
  text(pc1, pc2, label = text.lbls, pos=4, col ="blue", xpd=T, cex=0.8)
}
#PLS score plot with customizable graphical parameters
plot_PLS_scoresKB <- function(df, inx1 = 1, inx2 = 2,
                             reg = 0.95, show = TRUE,
                             setcolour = "time") {
  
  match.arg(setcolour, c("time", "treatment"))
  
    #Prepare df if not cleaned
  df <- filter_NA_Mann(df)
  df <- fillNA(df)
  df <- logTransform(df)
  df <- normScale(df)
  #Perform PLSDA
  pls <- PLS_anal(df)
  #Extract scores for 2 specified components and arrange them with sample data 
  plstbl <- df$sampleData %>% 
    arrange(sample_ID) %>% 
    cbind(pls$scores[,inx1]) %>% 
    cbind(pls$scores[,inx2])%>%
    mutate(sample_ID = as.numeric(sample_ID)) %>% 
    mutate(time = as.character(time)) %>%
    arrange(sample_ID)
  plstbl$time <-  reorder(plstbl$time, order(plstbl$sample_ID))
  names(plstbl)[6] <- paste("Component", inx1, "(", round(100*pls$Xvar[inx1]/pls$Xtotvar, 1), "%)")
  names(plstbl)[7] <- paste("Component", inx2, "(", round(100*pls$Xvar[inx2]/pls$Xtotvar, 1), "%)")
  
  #Prepare ggplot object and plot PLS scores
  if (setcolour == "time") {
    plsgg <- ggplot(plstbl, aes(plstbl[,6], plstbl[,7],shape=treatment, colour=time))
    plsgg+
      geom_point()+
      geom_text(aes(label=sample_ID),hjust=-0.4, vjust=-0.5, size=3)+
      theme_bw()+
      xlab(names(plstbl)[6])+
      ylab(names(plstbl)[7])+
      guides(colour=guide_legend(title="Time (min)"),
             shape=guide_legend(title="Treatement"))
  } else if (setcolour == "treatment") {
    plsgg <- ggplot(plstbl, aes(plstbl[,6], plstbl[,7],shape=time, colour=treatment))
    plsgg+
      geom_point()+
      geom_text(aes(label=sample_ID),hjust=-0.4, vjust=-0.5, size=3)+
      theme_bw()+
      xlab(names(plstbl)[6])+
      ylab(names(plstbl)[7])+
      guides(colour=guide_legend(title="Treatment"),
             shape=guide_legend(title="Time (min)"))
  } #if END
  
} #function END

#' PLS analysis

#' Uses \code{"oscorespls"} method of \code{\link[pls]{plsr}} function .
#' Writes two output files: \code{"pls_score.csv"} and \code{"pls_loadings.csv"}.
#' Adds \code{analSet$pls} element with \code{\link[pls]{plsr}} function output.
#' @param dataSet List, data set object generated by \code{\link[MSdata]{MS_to_MA}} function.
#' @param analSet List, containing the results of statistical analysis (can be just an empty list).
#' @return Native \code{analSet} with one added \code{$plsr} element containing \code{\link[pls]{plsr}} function output
#' @seealso \code{\link{PLS.Loadings}}, \code{\link{PLSDA.CV}}, \code{\link{PLSDA.Permut}}, \code{\link{PlotPLS}}
#' @export
# pls analysis using oscorespls so that VIP can be calculated
# note: the VIP is calculated only after PLSDA-CV is performed
# to determine the best # of comp. used for VIP
PLS_anal <- function(df) {
  datmat <-
    df %>%
    filter_NA() %>%
    fillNA() %>%
    intMatrix() %>%
    t()
  # Get groupnames as factor
  group <- mapvalues(row.names(datmat),
                     df$sampleData$sample_ID,
                     as.numeric(as.factor(df$sampleData$group)) - 1)
  pls <- pls::plsr(group~datmat, method = 'oscorespls');
  return(pls);
}

#' #' PLS loadings
#' #'
#' #' PLS loadings.
#' #' Adds loading matrix to \code{analSet$pls} element.
#' #'
#' #' @param dataSet List, data set object generated by \code{\link[MSdata]{MS_to_MA}} function.
#' #' @param analSet List, containing the results of statistical analysis (can be just an empty list).
#' #' @param inx1,inx2 The numbers of PC.
#' #' @return Native \code{analSet} with two added elements:
#' #' \itemize{
#' #' \item\code{$pls$load.x.uniq} - ???
#' #' \item\code{$pls$imp.loads} - loading matrix
#' #' }
#' #' @seealso \code{\link{PLS.Anal}}, \code{\link{PLSDA.CV}}, \code{\link{PLSDA.Permut}}, \code{\link{PlotPLS}}
#' #' @export
#'
#' PLS.Loadings<-function(dataSet, analSet, inx1 = 1, inx2 = 2){
#'   if (is.null(analSet$plsr)) stop("Please, conduct PLS.Anal first.")
#'   # named vector
#'   load1<-analSet$plsr$loadings[,inx1];
#'   load2<-analSet$plsr$loadings[,inx2];
#'   loadings = signif(as.matrix(cbind(load1, load2)),5);
#'
#'   ldName1<-paste("Loadings", inx1);
#'   ldName2<-paste("Loadings", inx2);
#'   colnames(loadings)<-c(ldName1, ldName2);
#'   load.x.uniq <- jitter(loadings[,1]);
#'   names(load.x.uniq) <- rownames(loadings);
#'   analSet$plsr$load.x.uniq <- load.x.uniq;
#'   analSet$plsr$imp.loads<-loadings; # set up loading matrix
#'   return(analSet);
#' }


#' Plot PLS
#'
#' Set of functions for plotting the results of PLS.
#'
#' @param dataSet List, data set object generated by \code{\link[MSdata]{MS_to_MA}} function.
#' @param analSet List, containing the results of statistical analysis (can be just an empty list).
#' @param imgName Image file name prefix.
#' @param format Image format, one of: "png", "tiff", "pdf", "ps", "svg"
#' @param dpi Image resolution.
#' @param width Image width.
#' @seealso \code{\link{PLS.Anal}}, \code{\link{PLS.Loadings}}, \code{\link{PLSDA.CV}}, \code{\link{PLSDA.Permut}}
#' @name PlotPLS
NULL

#' \code{PlotPLSPairSummary} - plot summary.
#' @param pc.num The number of plotted principal components.
#' @rdname PlotPLS
# plot pairwise summary
# PlotPLSPairSummary<-function(dataSet, analSet, imgName="pls_pair_", format="png", dpi=72, width=NA, pc.num=2){
#   if (is.null(analSet$plsr)) stop("Please, conduct PLS.Anal first.")
#
#   imgName = paste(imgName, "dpi", dpi, ".", format, sep="");
#   if(is.na(width)){
#     w <- 9;
#   }else if(width == 0){
#     w <- 7.2;
#     analSet$imgSet$pls.pair <- imgName;
#   }else{
#     w <- width;
#   }
#   h <- w;
#
#   Cairo::Cairo(file = imgName, unit="in", dpi=dpi, width=w, height=h, type=format, bg="white");
#   pclabels <- paste("Component", 1:pc.num, "\n", round(100*analSet$plsr$Xvar[1:pc.num]/analSet$plsr$Xtotvar,1), "%");
#   # pairs(analSet$plsr$scores[,1:pc.num], col=as.numeric(dataSet$cls)+1, pch=as.numeric(dataSet$cls)+1, labels=pclabels)
#   pairs(analSet$plsr$scores[,1:pc.num], col=GetColorSchema(dataSet), pch=as.numeric(dataSet$cls)+1, labels=pclabels)
#   dev.off();
#   frame()
#   grid::grid.raster(png::readPNG(imgName));
# }
#
#


#
#   # obtain ellipse points to the scatter plot for each category
#   lvs <- levels(dataSet$cls);
#   pts.array <- array(0, dim=c(100,2,length(lvs)));
#   for(i in 1:length(lvs)){
#     inx <-dataSet$cls == lvs[i];
#     groupVar<-var(cbind(lv1[inx],lv2[inx]), na.rm=T);
#     groupMean<-cbind(mean(lv1[inx], na.rm=T),mean(lv2[inx], na.rm=T));
#     pts.array[,,i] <- ellipse::ellipse(groupVar, centre = groupMean, level = reg, npoints=100);
#   }
#
#   xrg <- range (lv1, pts.array[,1,]);
#   yrg <- range (lv2, pts.array[,2,]);
#   x.ext<-(xrg[2]-xrg[1])/12;
#   y.ext<-(yrg[2]-yrg[1])/12;
#   xlims<-c(xrg[1]-x.ext, xrg[2]+x.ext);
#   ylims<-c(yrg[1]-y.ext, yrg[2]+y.ext);
#
#   ## cols = as.numeric(dataSet$cls)+1;
#   cols <- GetColorSchema(dataSet, gray.scale);
#   uniq.cols <- unique(cols);
#
#   plot(lv1, lv2, xlab=xlabel, xlim=xlims, ylim=ylims, ylab=ylabel, type='n', main="Scores Plot");
#   grid(col = "lightgray", lty = "dotted", lwd = 1);
#
#   # make sure name and number of the same order DO NOT USE levels, which may be different
#   legend.nm <- unique(as.character(dataSet$cls));
#   ## uniq.cols <- unique(cols);
#
#   ## BHAN: when same color is choosen for black/white; it makes an error
#   # names(uniq.cols) <- legend.nm;
#   if ( length(uniq.cols) > 1 ) {
#     names(uniq.cols) <- legend.nm;
#   }
#   # draw ellipse
#   for(i in 1:length(lvs)){
#     if ( length(uniq.cols) > 1) {
#       polygon(pts.array[,,i], col=adjustcolor(uniq.cols[lvs[i]], alpha.f=0.25), border=NA);
#     } else {
#       polygon(pts.array[,,i], col=adjustcolor(uniq.cols, alpha.f=0.25), border=NA);
#     }
#     if(gray.scale) {
#       lines(pts.array[,,i], col=adjustcolor("black", alpha.f=0.5), lty=2);
#     }
#   }
#
#   pchs <- GetShapeSchema(dataSet, show, gray.scale);
#   if(gray.scale) {
#     cols <- rep("black", length(cols));
#   }
#   if(show){ # display sample name set on
#     text(lv1, lv2, label=text.lbls, pos=4, xpd=T, cex=0.75);
#     points(lv1, lv2, pch=pchs, col=cols);
#   }else{
#     if (length(uniq.cols) == 1) {
#       points(lv1, lv2, pch=pchs, col=cols, cex=1.0);
#     } else {
#       if(gray.scale | (!is.null(dataSet$shapeVec) && all(dataSet$shapeVec>0))){
#         points(lv1, lv2, pch=pchs, col=cols, cex=1.8);
#       }else{
#         points(lv1, lv2, pch=21, bg=cols, cex=2);
#       }
#     }
#   }
#
#   uniq.pchs <- unique(pchs);
#   if(gray.scale) {
#     uniq.cols <- "black";
#   }
#   legend("topright", legend = legend.nm, pch=uniq.pchs, col=uniq.cols);
# }
